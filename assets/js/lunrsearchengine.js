
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "/about",
    "title": "一群热爱技术的小伙伴 💁‍♂️",
    "body": "我们来自五湖四海，有着不一样的生活，但是我们都热爱技术，喜欢黑魔法 🧙‍♂️ 。 在这里我们摸着鱼 🐟，分享着技术 🙆‍♂️。 欢迎加入我们 😝，一起 Touch My Fish。 "
    }, {
    "id": 2,
    "url": "/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                                     Python 中如何优雅地将字典转化对象                              :               羡慕 JS 的语法糖:                                                                                                                                                 19 Jul 2019                &lt;/span&gt;                                                                                                                                                                                                                                                                                                        常用内存缓存 cache模块                              :               有时候想做点缓存优化，但又不想去用其他的中间件，例如redis等，本文介绍了一些基于内存的缓存实现方法。:                                                                                                                                                 18 Jul 2019                &lt;/span&gt;                                                                                                  All Stories:                                                                                       Python 中如何优雅地将字典转化对象              :       羡慕 JS 的语法糖:                                                                                                         Mayne                19 Jul 2019                                                                                                                      常用内存缓存 cache模块              :       有时候想做点缓存优化，但又不想去用其他的中间件，例如redis等，本文介绍了一些基于内存的缓存实现方法。:                                                                                                         Sky                18 Jul 2019                                                                                                                      GIL与python线程安全 单例模式 singleton              :       什么是GILglobal interpreter lock – 全局解释器锁CPython 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性:                                                                                                         Sky                17 Jul 2019                                                                                                                      go fmt 引起的 stack overflow              :       在 GO 里实现 String 方法会格式化输出。例如：```package main:                                                                                                         vnotes                16 Jul 2019                                                                                                                      lazydocker 使用时 log 过长的解决方案              :       Lazydocker The lazier way to manage everything docker - jesseduffield/lazydocker:                                                                                                         elfgzp                14 Jul 2019                                                                                                                      两个常量对象，None 与 . . . (ellipsis)              :       本文介绍了两个常量对象None与…(ellipsis)的一些特性，前者非常常见，后者却非常少用，但其实它有一些非常pythonic的用法。:                                                                                                         Sky                10 Jul 2019                                            "
    }, {
    "id": 4,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "/python/2019/07/19/dict2obj-in-py.html",
    "title": "Python 中如何优雅地将字典转化对象",
    "body": "2019/07/19 - 羡慕 JS 的语法糖: 先看下面一段 JS 代码 12345678910111213let npc = {    name: {       first :  san ,      last:  zhang     },    hp: 1000}npc. name. first//  san npc[ name ]. first//  san JS中的“字典”天然就是一个对象，所以可以通过点的方式访问对象属性。而 python 中通过键获取映射值通常需要下面这样。 12a_dict[ key ] a_dict. get( key )有点怀念 JS 简洁的语法了。你要知道用点访问，可以少敲 [ 、   *2 、 ] 4 个字符，这个语法糖难道不甜嘛？ 在 python 中要用点访问，必须把字典转化为对象。 字典转对象: 强大的内置电池 1234567891011121314151617In [1]: from types import SimpleNamespaceIn [2]: npc = {  . . . : 'name': {  . . . :  'first': 'san',  . . . :  'last': 'zhang'  . . . : },  . . . : 'hp': 1000  . . . : }In [3]: npcOut[3]: {'name': {'first': 'san', 'last': 'zhang'}, 'hp': 1000}In [4]: npc = SimpleNamespace(**npc)In [5]: npc. hpOut[5]: 1000到目前为止一切 OK，又可以点点点了。 12345678910In [6]: npc. nameOut[6]: {'first': 'san', 'last': 'zhang'}In [7]: npc. name. first---------------------------------------------------------------------------AttributeError              Traceback (most recent call last)&lt;ipython-input-7-7749b491d382&gt; in &lt;module&gt;----&gt; 1 npc. name. firstAttributeError: 'dict' object has no attribute 'first'很明显，对于嵌套字典 SimpleNamespace 没法自动处理，只能转换第一层字典为对象。我们需要对其进行递归处理。 处理通用的嵌套字典: 嵌套字典中的值，可能是 list，可能是 dict，也可能是基础数据类型。因此在处理递归的过程中，我们需要对不同类型的值，做不同的处理。 下面推荐内置电池中的 singledispatch 123456789101112In [12]: singledispatch?Signature: singledispatch(func)Docstring:Single-dispatch generic function decorator. Transforms a function into a generic function, which can have differentbehaviours depending upon the type of its first argument. The decoratedfunction acts as the default implementation, and additionalimplementations can be registered using the register() attribute of thegeneric function. File:   /usr/local/Cellar/python/3. 7. 3/Frameworks/Python. framework/Versions/3. 7/lib/python3. 7/functools. pyType:   function简单的说，它是一个装饰器。可以为被装饰函数第一个参数，注册不同的处理逻辑。 举个例子 1234567891011121314151617In [13]: @singledispatch  . . . : def mytype(obj):  . . . :   return objIn [16]: @mytype. register(list)  . . . : def handle_list(obj):  . . . :   print( i am list )  . . . :   return obj# 返回 list 之前，打印自己的类型In [17]: mytype([1,2,3,4])i am listOut[17]: [1, 2, 3, 4]# 因为没有注册对于字符串的处理函数，所以会直接返回 obj，即 mytype 的处理逻辑。In [18]: mytype( a )Out[18]: 'a'下面我们来构建一个可以处理嵌套字典的 dict2obj 函数 12345678910111213In [22]: @singledispatch  . . . : def dict2obj(o):  . . . :   return o  . . . :In [23]: @dict2obj. register(dict)  . . . : def handle_obj(obj):  . . . :   return SimpleNamespace(**{ k:dict2obj(v) for k,v in obj. items() })  . . . :In [24]: @dict2obj. register(list)  . . . : def handle_list(lst):  . . . :   return [ dict2obj(i) for i in lst]测试一下 1234567891011121314151617181920212223242526In [28]: zhangsan = {'name': {'first': 'san', 'last': 'zhang'}, 'hp': 1000}In [29]: lisi = {'name': {'first': 'si', 'last': 'li'}, 'hp': 1000, 'friends': [zhangsan]}In [32]: lisiOut[32]:{'name': {'first': 'si', 'last': 'li'}, 'hp': 1000, 'friends': [{'name': {'first': 'san', 'last': 'zhang'}, 'hp': 1000}]}In [33]: obj_lisi = dict2obj(lisi)In [34]: obj_lisi. nameOut[34]: namespace(first='si', last='li')In [35]: obj_lisi. name. firstOut[35]: 'si'In [36]: obj_lisi. hpOut[36]: 1000In [37]: obj_lisi. friends[0]. nameOut[37]: namespace(first='san', last='zhang')In [38]: obj_lisi. friends[0]. name. firstOut[38]: 'san'完整演示代码: https://gist. github. com/mayneyao/6a09bd97237f23c0cb68730715b21851 "
    }, {
    "id": 6,
    "url": "/python/2019/07/18/Meomery-Cache.html",
    "title": "常用内存缓存 cache模块",
    "body": "2019/07/18 - 有时候想做点缓存优化，但又不想去用其他的中间件，例如redis等，本文介绍了一些基于内存的缓存实现方法。 自定义实现cache: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timedef cached(ttl=3600*24, maxsize=None):  def decorator(func):    cache = {}    def wrapper(*args,**kwargs):      key = str(args)+str(kwargs)      if key not in cache or time. time() &gt; cache[key]['expires']:        if len(cache) &gt; maxsize:          print('cache buffer pop: %s' %key)          for key in cache. keys():            cache. pop(key)            break        else:          print ('missing: %s' %key)        cache[key] = { value : func(*args,**kwargs), expires :time. time()+ ttl}      else:        print ('hit: %s' %key)      return cache[key]['value']    return wrapper  return decorator@cached(ttl=5, maxsize=2)def add(x, y):  return x+y# 插入缓存for i in range(3):  print('1+%s = ' %i, add(1, i))# 缓存命中print ('==='*10)for i in range(3):  print('1+%s = ' %i, add(1, i))# 缓存过期print ('==='*10)time. sleep(5)for i in range(3):  print('1+%s = ' %i, add(1, i))1234567891011121314151617181920missing: (1, 0){}1+0 = 1missing: (1, 1){}1+1 = 2missing: (1, 2){}1+2 = 3==============================hit: (1, 0){}1+0 = 1hit: (1, 1){}1+1 = 2hit: (1, 2){}1+2 = 3==============================cache buffer pop: (1, 0){}1+0 = 1cache buffer pop: (1, 1){}1+1 = 2cache buffer pop: (1, 2){}1+2 = 3python自带模块functools. lru_cache: @functools. lru_cache(maxsize=128, typed=False)一个为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。 特点:    由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。     不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。     如果 maxsize 设置为 None ，LRU功能将被禁用且缓存数量无上限。 maxsize 设置为2的幂时可获得最佳性能。     如果 typed 设置为true，不同类型的函数参数将被分别缓存。例如， f(3) 和 f(3. 0) 将被视为不同而分别缓存。  命中率查看: 为了衡量缓存的有效性以便调整 maxsize 形参，被装饰的函数带有一个 cache_info() 函数。当调用 cache_info() 函数时，返回一个具名元组，包含命中次数 hits，未命中次数 misses ，最大缓存数量 maxsize 和 当前缓存大小 currsize。在多线程环境中，命中数与未命中数是不完全准确的。 适用: “最久未使用算法”（LRU）缓存 在“最近的调用是即将到来的调用的最佳预测因子”时性能最好（比如，新闻服务器上最受欢迎的文章倾向于每天更改）。 “缓存大小限制”参数保证缓存不会在长时间运行的进程比如说网站服务器上无限制的增加自身的大小。 一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。 其他: 该装饰器也提供了一个用于清理/使缓存失效的函数 cache_clear() 。原始的未经装饰的函数可以通过 wrapped 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。 1234567891011121314# 简单案例，通过cache_info查看命中率import functools@functools. lru_cache(maxsize=100)def add(x, y):  return x+yprint ('1+2 =',add(1,2))print (add. cache_info())print ('3+4 =',add(3,4))print (add. cache_info())print ('1+2 =',add(1,2))print (add. cache_info())1234561+2 = 3CacheInfo(hits=0, misses=1, maxsize=100, currsize=1)3+4 = 7CacheInfo(hits=0, misses=2, maxsize=100, currsize=2)1+2 = 3CacheInfo(hits=1, misses=2, maxsize=100, currsize=2)12345678910# 获取原始函数import functools@functools. lru_cache(maxsize=100)def add(x, y):  return x+yprint('当前函数：', add)print('获取原始函数：', add. __wrapped__)12当前函数： &lt;functools. _lru_cache_wrapper object at 0x10de27e10&gt;获取原始函数： &lt;function add at 0x10da56598&gt;cachetools模块: 1pip install cachetools1234567[33mWARNING: The directory '/Users/klook/Library/Caches/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag. [0m[33mWARNING: The directory '/Users/klook/Library/Caches/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag. [0mCollecting cachetools Downloading https://files. pythonhosted. org/packages/2f/a6/30b0a0bef12283e83e58c1d6e7b5aabc7acfc4110df81a4471655d33e704/cachetools-3. 1. 1-py2. py3-none-any. whlInstalling collected packages: cachetoolsSuccessfully installed cachetools-3. 1. 1Note: you may need to restart the kernel to use updated packages. 12345# 看看可用模块import cachetoolsfor item in dir(cachetools):  if not item. startswith('__'):    print(item)1234567891011121314151617CacheLFUCacheLRUCacheRRCacheTTLCache_update_wrapperabcabsolute_importcachecachedcachedmethodfunctoolskeyslfulrurrttlcache策略: cachetools支持的cache策略有以下几种方式：Cache   Simple cache。LFUCache Least Frequently Used (LFU) cache implementation. LRUCache Least Recently Used (LRU) cache implementation. RRCache Random Replacement (RR) cache implementation. TTLCache LRU Cache implementation with per-item time-to-live (TTL) value. LRU (Least recently used) 最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高。LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。 使用方法:  利用cached12345678# cached方法， 装饰器， 修饰函数def cached(cache, key=keys. hashkey, lock=None):     Decorator to wrap a function with a memoizing callable that saves  results in a cache.        def decorator(func):    if cache is None:1234567891011121314# 用字典来做cachefrom cachetools import cached@cached(cache={})def add(x, y):  print ('%s %s missing' %(x,y))  return x+yfor i in range(3):  print (add(i,10))print ('==='*10)for i in range(3):  print (add(i,10))123456789100 10 missing101 10 missing112 10 missing12==============================10111212345678910111213# 使用Cachetools. Cache来做缓存from cachetools import cached, Cache@cached(cache=Cache(maxsize=2))  ## 注意这里的maxsize不能少于你的存取数量，否则缓存会失效def add(x, y):  print ('%s %s missing' %(x,y))  return x+yfor i in range(3):  print (add(i,10))print ('==='*10)for i in range(3):  print (add(i,10))123456789101112130 10 missing101 10 missing112 10 missing12==============================0 10 missing101 10 missing112 10 missing1212345678910111213141516# 使用Cachetools. Cache来做缓存from cachetools import cached, LRUCache@cached(cache=LRUCache(maxsize=2)) ## 注意这里的maxsize不能少于你的存取数量，否则缓存会失效def add(x, y):  print ('%s %s missing' %(x,y))  return x+yfor i in range(3):   print ('result---&gt;', add(i,10))for i in range(3):   print ('result---&gt;', add(i,10))print ('==='*10)for i in range(3):  print ('result---&gt;', add(i,10))123456789101112131415161718190 10 missingresult---&gt; 101 10 missingresult---&gt; 112 10 missingresult---&gt; 120 10 missingresult---&gt; 101 10 missingresult---&gt; 112 10 missingresult---&gt; 12==============================0 10 missingresult---&gt; 101 10 missingresult---&gt; 112 10 missingresult---&gt; 12 利用cachedmethod12345678910# cachedmethod方法， 装饰器， 修饰类方法def cachedmethod(cache, key=keys. hashkey, lock=None):     Decorator to wrap a class or instance method with a memoizing  callable that saves results in a cache.        def decorator(method):    if lock is None:      def wrapper(self, *args, **kwargs):        c = cache(self) # 这里导致调用不是很方便，可以用IDE查看源码12345678910111213141516171819202122# cachedmethod的使用from operator import attrgetterfrom cachetools import Cache, cachedmethodclass Test:  def __init__(self, maxsize=3): ## 注意这里的maxsize不能少于你的存取数量，否则缓存会失效    self. cache = Cache(maxsize=maxsize)  @cachedmethod(cache=attrgetter('cache'))  def add(self, x, y):    print ('%s %s missing' %(x,y))    return x+yt = Test()for i in range(3):   print ('result---&gt;', t. add(i,10))for i in range(3):   print ('result---&gt;', t. add(i,10))print ('==='*10)for i in range(3):  print ('result---&gt;', t. add(i,10))123456789101112130 10 missingresult---&gt; 101 10 missingresult---&gt; 112 10 missingresult---&gt; 12result---&gt; 10result---&gt; 11result---&gt; 12==============================result---&gt; 10result---&gt; 11result---&gt; 12自定义利用TTLCache: 12345678910111213141516171819202122232425262728293031323334353637383940414243from cachetools import TTLCachefrom functools import wrapsclass Memorize:  def __init__(self, maxsize, ttl, create_key=None):    self. create_key = create_key or (lambda *args, **kwargs: str(args)+str(kwargs))    self. ttl = ttl    self. _cache = TTLCache(maxsize=maxsize, ttl=ttl)  def __call__(self, func):    @wraps(func)    def wrapper(*args, **kwargs):      key =  {}. {} . format(func. __qualname__, self. create_key(*args, **kwargs))      value = self. _cache. get(key, None)      if value is None:        value = func(*args, **kwargs)        if value is not None:          print ('missing----')          self. _cache[key] = value      else:        print ('hit----')      return value    return wrapper@Memorize(maxsize=3, ttl=2)def add(x,y):  return x+yfor i in range(3):   print ('result---&gt;', add(i,10))for i in range(3):   print ('result---&gt;', add(i,10))import timetime. sleep(2) # sleep 2 secondsprint ('==='*10)for i in range(3):  print ('result---&gt;', add(i,10))12345678910111213141516171819missing----result---&gt; 10missing----result---&gt; 11missing----result---&gt; 12hit----result---&gt; 10hit----result---&gt; 11hit----result---&gt; 12==============================missing----result---&gt; 10missing----result---&gt; 11missing----result---&gt; 12"
    }, {
    "id": 7,
    "url": "/python/2019/07/17/GIL-Thread-safe.html",
    "title": "GIL与python线程安全 单例模式 singleton",
    "body": "2019/07/17 - 什么是GIL: global interpreter lock – 全局解释器锁CPython 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性 什么是线程安全: 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 python 线程安全: GIL保证的是bytecode同一时刻只能被一个线程执行，但是同一个操作是对应多个bytecodes的，在此时线程切换将会造成数据污染。 python 线程调度: python使用C实现的，实际上python的线程就是C语言的pthread，通过操作系统调度算法进行调度；python线程虽说是系统线程（遵循系统线程调度），但是却有自己的切换条件，在python2中默认是字节码执行100条，python3. 2后是时间切片，达到规则后就自动强制释放GIL。 python2线程切换条件: 123456789# sys. setcheckinterval(interval)# Set the interpreter’s “check interval”. # This integer value determines how often the interpreter checks for periodic things such as thread switches and signal handlers. # The default is 100, meaning the check is performed every 100 Python virtual instructions. # Setting it to a larger value may increase performance for programs using threads. Setting it to a value &lt;= 0 checks every virtual instruction,# maximizing responsiveness as well as overhead. import sysprint(sys. getcheckinterval())12345100/Users/klook/anaconda3/envs/3. 7. 1_basic/lib/python3. 7/site-packages/ipykernel_launcher. py:9: DeprecationWarning: sys. getcheckinterval() and sys. setcheckinterval() are deprecated.  Use sys. getswitchinterval() instead.  if __name__ == '__main__':python3. 2后版本线程切换条件: 123456789# sys. setswitchinterval(interval)# Set the interpreter’s thread switch interval (in seconds). # This floating-point value determines the ideal duration of the “timeslices” allocated to concurrently running Python threads. # Please note that the actual value can be higher, especially if long-running internal functions or methods are used. # Also, which thread becomes scheduled at the end of the interval is the operating system’s decision. The interpreter doesn’t have its own scheduler. # New in version 3. 2. import sysprint(sys. getswitchinterval())10. 005线程安全的单例模式（面试可能遇到哦）: 利用模块只加载一次的特性: 12345678class Singleton:  __instance = None  def __new__(cls, age, name):    if not cls. __instance:      cls. __instance = object. __new__(cls)    return cls. __instancesingleton = Singleton(99, 'sky')给资源加锁: 123456789101112import threadinglock = threading. Lock()class Singleton:  __instance = None  def __new__(cls, age, name):    with lock:      if not cls. __instance:        cls. __instance = object. __new__(cls)    return cls. __instance1"
    }, {
    "id": 8,
    "url": "/golang/2019/07/16/go-stackover.html",
    "title": "go fmt 引起的 stack overflow",
    "body": "2019/07/16 - 在 GO 里实现 String 方法会格式化输出。例如： 1234567891011121314151617181920package mainimport (	 fmt )type People struct {	Name string	Age int	Sex string}func (p *People) String() string {	return fmt. Sprintf( people info: %+v , p)}func main() {	p := &amp;People{Name:  Lucy , Age: 18, Sex:  M }	fmt. Println(p)}预期的结果是：people info: &amp;{Name:Lucy Age:18 Sex:M}实际的结果是：  runtime: goroutine stack exceeds 1000000000-byte limitfatal error: stack overflowruntime stack: 在 go 的源码里：src/fmt/print. go::Stringer， Stringer 接口有 String 方法，People struct 也有 String 方法，间接实现了 Stringer 接口，因此出现了 stack overflow 的错误，递归了。 解决办法：:  把 String 方法改为 ToString 在 People. String 方法里传递属性，即把 fmt. Sprintf( people info: %+v , p) 改为 fmt. Sprintf( people info: Name:%s, Age:%d, Sex:%s , p. Name, p. Age, p. Sex)参考文章: golang fmt递归引起stack overflow异常 "
    }, {
    "id": 9,
    "url": "/tools/2019/07/14/lazydocker.html",
    "title": "lazydocker 使用时 log 过长的解决方案",
    "body": "2019/07/14 - Lazydocker:  The lazier way to manage everything docker - jesseduffield/lazydocker 这是一个非常好用的小工具，但是在使用过程中发现 log 过长时效果不是很好。 阅读官方 README 后发现是可以配置的，配置文件路径如下： Locations:- OSX: `~/Library/Application Support/jesseduffield/lazydocker/config. yml`- Linux: `~/. config/jesseduffield/lazydocker/config. yml`- Windows: `C:\\Users\\&lt;User&gt;\\AppData\\Roaming\\jesseduffield\\lazydocker\\config. yml` (I think)但是这里有个坑了，在 OSX 下的路径应该为：~/Library/Application\ Support/jesseduffield/lazydocker/config. yml⚠️注意那个右斜杠！ 默认的配置如下，如果上面路径不存在配置文件可以复制进去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748gui: scrollHeight: 2 theme:  activeBorderColor:  - green  - bold  inactiveBorderColor:  - white  optionsTextColor:  - blue returnImmediately: false wrapMainPanel: falsereporting: undeterminedcommandTemplates: dockerCompose: docker-compose restartService: '{{ . DockerCompose }} restart {{ . Service. Name }}' stopService: '{{ . DockerCompose }} stop {{ . Service. Name }}' serviceLogs: '{{ . DockerCompose }} logs --since=60m --follow {{ . Service. Name }}' viewServiceLogs: '{{ . DockerCompose }} logs --follow {{ . Service. Name }}' rebuildService: '{{ . DockerCompose }} up -d --build {{ . Service. Name }}' recreateService: '{{ . DockerCompose }} up -d --force-recreate {{ . Service. Name }}' viewContainerLogs: docker logs --timestamps --follow --since=60m {{ . Container. ID  }} containerLogs: docker logs --timestamps --follow --since=60m {{ . Container. ID }} allLogs: '{{ . DockerCompose }} logs --tail=300 --follow' viewAlLogs: '{{ . DockerCompose }} logs' dockerComposeConfig: '{{ . DockerCompose }} config' checkDockerComposeConfig: '{{ . DockerCompose }} config --quiet' serviceTop: '{{ . DockerCompose }} top {{ . Service. Name }}'customCommands: containers: - name: bash  attach: true  command: docker exec -it {{ . Container. ID }} /bin/sh  serviceNames: []oS: openCommand: open {{filename}} openLinkCommand: open {{link}}update: method: neverstats: graphs: - caption: CPU (%)  statPath: DerivedStats. CPUPercentage  color: blue - caption: Memory (%)  statPath: DerivedStats. MemoryPercentage  color: green将其中的 wrapMainPanel 设置为 true，log 过长的问题就可以解决了。 我们来看看效果。 "
    }, {
    "id": 10,
    "url": "/python/2019/07/10/None-ellispsis.html",
    "title": "两个常量对象，None 与 ...(ellipsis)",
    "body": "2019/07/10 - 本文介绍了两个常量对象None与…(ellipsis)的一些特性，前者非常常见，后者却非常少用，但其实它有一些非常pythonic的用法。 python版本: 1234# python 版本import sysprint(sys. version)123. 6. 6 |Anaconda, Inc. | (default, Jun 28 2018, 11:07:29)[GCC 4. 2. 1 Compatible Clang 4. 0. 1 (tags/RELEASE_401/final)]1、None对象: None只是一个特殊的对象，不是False，也不是Null 1print(type(None))1&lt;class 'NoneType'&gt;12345# 1. 单例属性a = Noneb = Noneprint (a == b)1True123456789#2. 用is 和is not判断a = Noneif a is None:  print ('a is None')b = Falseif b is not None:  print ('b is not None')12a is Noneb is not None123#3. 不可添加或者更改属性a = Nonea. test = 112345678---------------------------------------------------------------------------AttributeError              Traceback (most recent call last)&lt;ipython-input-20-4c7cc21b8374&gt; in &lt;module&gt;()   2 a = None   3----&gt; 4 a. test = 11AttributeError: 'NoneType' object has no attribute 'test'1234567# 4.  函数不明确return，默认返回Nonedef test():  passif test() is None:  print ('test return None')12#5. bool类型print (bool(None))1False2、… 是一个对象，只是一个对象而已: 1print(type(. . . ))1&lt;class 'ellipsis'&gt;1234#1. 单例属性t = . . . d = . . . print (t == d)1True12345678#2. 用is 和is not判断a = . . . if a is not None:  print ('a is not None')if a is . . . :  print ('a is . . . ')12a is not Nonea is . . . 1234#3. 不可添加或者更改属性a = . . . a. test = 1123456789---------------------------------------------------------------------------AttributeError              Traceback (most recent call last)&lt;ipython-input-28-8f3574f64285&gt; in &lt;module&gt;()   1 #3. 不可添加或者更改属性   2 a = . . . ----&gt; 3 a. test = 112AttributeError: 'ellipsis' object has no attribute 'test'123#5. bool类型print (bool(. . . ))12Trueellipsis对象的pythonic用法: 123456789101112131415161718#6.  用法, 无限递推 (from https://farer. org/2017/11/29/python-ellipsis-object/)class Mogic(object):  def __getitem__(self, key):    if len(key) == 3 and key[2] is Ellipsis:      d = key[1] - key[0]      r = key[0]      while True:        yield r        r += dap = Mogic()for i in ap[1,2,. . . ]:  if i&lt;20:    print (i)  else:    break ## 阻止循环123456789101112131415161718191234567891011121314151617181912345678#7. numpy中的玩法(实现原理同上)import numpy as npa = np. arange(6). reshape(2,3)for x in np. nditer(a, op_flags=['readwrite']):  x[. . . ] = 2 * xprint (a)12[[ 0 2 4] [ 6 8 10]]123456789101112131415161718#8. type hints用法# 在类型提示中使用 Callable，不确定参数签名时，可以用 Ellipsis 占位。from typing import Callabledef foo() -&gt; Callable[. . . , int]:  return lambda x: 1# 使用 Tuple 时返回不定长的 tuple，用 Ellipsis 进行指定。from typing import Tupledef bar() -&gt; Tuple[int, . . . ]:  return (1,2,3)def buzz() -&gt; Tuple[int, . . . ]:  return (1,2,3,4)"
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});